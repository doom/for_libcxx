/*
** Created by doom on 20/10/18.
*/

#ifndef FOR_LIBCXX_ALGORITHM
#define FOR_LIBCXX_ALGORITHM

#include <iterator>
#include <utility>
#include <functional>
#include <details/move_and_forward.hpp>

namespace std
{
    template <typename T>
    constexpr const T &min(const T &a, const T &b) noexcept(noexcept(a < b))
    {
        return a > b ? b : a;
    }

    template <typename T>
    constexpr const T &max(const T &a, const T &b) noexcept(noexcept(a > b))
    {
        return a < b ? b : a;
    }

    template <typename ForwardIt, typename Comparator>
    constexpr ForwardIt min_element(ForwardIt first, ForwardIt last, Comparator cmp) noexcept
    {
        if (first == last)
            return last;

        auto smol = first;

        while (++first != last) {
            if (cmp(*first, *smol))
                smol = first;
        }
        return smol;
    }

    template <typename ForwardIt>
    constexpr ForwardIt min_element(ForwardIt first, ForwardIt last) noexcept
    {
        return min_element(first, last, std::less<>());
    }

    template <typename ForwardIt, typename Comparator>
    constexpr ForwardIt max_element(ForwardIt first, ForwardIt last, Comparator cmp) noexcept
    {
        if (first == last)
            return last;

        auto big = first;

        while (++first != last) {
            if (cmp(*big, *first))
                big = first;
        }
        return big;
    }

    template <typename ForwardIt>
    constexpr ForwardIt max_element(ForwardIt first, ForwardIt last) noexcept
    {
        return max_element(first, last, std::less<>());
    }

    template <typename ForwardIt, typename Comparator>
    std::pair<ForwardIt, ForwardIt> minmax_element(ForwardIt first, ForwardIt last, Comparator is_less)
    {
        ForwardIt smol = first;
        ForwardIt big = first;

        if (first == last || ++first == last) {
            return {smol, big};
        }

        if (is_less(*first, *smol)) {
            smol = first;
        } else {
            big = first;
        }

        while (++first != last) {
            ForwardIt i = first;

            if (++first == last) {
                if (is_less(*i, *smol)) {
                    smol = i;
                } else if (!(is_less(*i, *big))) {
                    big = i;
                }
                break;
            } else {
                if (is_less(*first, *i)) {
                    if (is_less(*first, *smol)) {
                        smol = first;
                    }
                    if (!(is_less(*i, *big))) {
                        big = i;
                    }
                } else {
                    if (is_less(*i, *smol)) {
                        smol = i;
                    }
                    if (!(is_less(*first, *big))) {
                        big = first;
                    }
                }
            }
        }

        return {smol, big};
    }

    template <typename ForwardIt>
    std::pair<ForwardIt, ForwardIt> minmax_element(ForwardIt first, ForwardIt last)
    {
        return std::minmax_element(first, last, std::less<>());
    }

    template <typename InputIt, typename UnaryPredicate>
    constexpr InputIt find_if(InputIt first, InputIt last, UnaryPredicate p) noexcept
    {
        while (first != last) {
            if (p(*first)) {
                return first;
            }
            ++first;
        }
        return last;
    }

    template <typename InputIt, typename UnaryPredicate>
    constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate p) noexcept
    {
        return find_if(first, last, [&p](auto &&v) {
            return !p(std::forward<decltype(v)>(v));
        });
    }

    template <typename InputIt, typename T>
    constexpr InputIt find(InputIt first, InputIt last, const T &value) noexcept
    {
        return find_if(first, last, [&value](auto &&v) {
            value == std::forward<decltype(v)>(v);
        });
    }

    template <typename InputIt, typename UnaryPredicate>
    constexpr bool all_of(InputIt first, InputIt last, UnaryPredicate p)
    {
        while (first != last) {
            if (!p(*first)) {
                return false;
            }
            ++first;
        }
        return true;
    }

    template <typename InputIt, typename UnaryPredicate>
    constexpr bool any_of(InputIt first, InputIt last, UnaryPredicate p)
    {
        while (first != last) {
            if (p(*first)) {
                return true;
            }
            ++first;
        }
        return false;
    }

    template <typename InputIt, typename UnaryPredicate>
    constexpr bool none_of(InputIt first, InputIt last, UnaryPredicate p)
    {
        while (first != last) {
            if (p(*first)) {
                return false;
            }
            ++first;
        }
        return true;
    }

    template <typename InputIt, typename UnaryPredicate>
    constexpr typename std::iterator_traits<InputIt>::difference_type count_if(InputIt first,
                                                                               InputIt last,
                                                                               UnaryPredicate p) noexcept
    {
        auto ret = 0;

        while (first != last) {
            if (p(*first)) {
                ++ret;
            }
        }
        return ret;
    }

    template <typename InputIt, typename T>
    constexpr typename std::iterator_traits<InputIt>::difference_type count(InputIt first,
                                                                            InputIt last,
                                                                            const T &value) noexcept
    {
        return count_if(first, last, [&value](auto &&v) {
            return value == std::forward<decltype(v)>(v);
        });
    }

    template <typename InputIt, typename OutputIt>
    constexpr OutputIt copy(InputIt in_first, InputIt in_last, OutputIt out_first)
    {
        //TODO: optimize using memmove for trivially copyable types

        while (in_first != in_last) {
            *out_first = *in_first;
            ++out_first;
            ++in_first;
        }
        return out_first;
    }

    template <typename InputIt, typename OutputIt>
    constexpr OutputIt move(InputIt in_first, InputIt in_last, OutputIt out_first)
    {
        while (in_first != in_last) {
            *out_first = std::move(*in_first);
            ++out_first;
            ++in_first;
        }
        return out_first;
    }

    template <typename InputIt, typename OutputIt>
    constexpr OutputIt move_backward(InputIt in_first, InputIt in_last, OutputIt out_last)
    {
        while (in_first != in_last) {
            --out_last;
            --in_last;
            *out_last = std::move(*in_last);
        }
        return out_last;
    }

    template <typename InputIt, typename OutputIt, typename UnaryOperation>
    constexpr OutputIt transform(InputIt in_first, InputIt in_last, OutputIt out_first, UnaryOperation f)
    {
        while (in_first != in_last) {
            *out_first++ = f(*in_first++);
        }
        return out_first;
    }

    template <typename InputIt1, typename InputIt2, typename OutputIt, typename BinaryOperation>
    constexpr OutputIt transform(InputIt1 in_first1, InputIt1 in_last1, InputIt2 in_first2,
                                 OutputIt out_first, BinaryOperation f)
    {
        while (in_first1 != in_last1) {
            *out_first++ = f(*in_first1++, *in_first2++);
        }
        return out_first;
    }

    template <typename InputIt, typename UnaryFunction>
    constexpr UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f)
    {
        while (first != last) {
            f(*first);
            ++first;
        }
        return f;
    }
}

#endif /* !FOR_LIBCXX_ALGORITHM */
