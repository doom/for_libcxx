/*
** Created by doom on 09/10/18.
*/

#ifndef FOR_LIBCXX_TYPE_TRAITS
#define FOR_LIBCXX_TYPE_TRAITS

namespace std
{
    template <typename T, T v>
    struct integral_constant
    {
        using type = integral_constant<T, v>;

        using value_type = T;
        static constexpr const T value = v;

        constexpr operator value_type() const noexcept
        {
            return value;
        }

        constexpr value_type operator()() const noexcept
        {
            return value;
        }
    };

    template <bool value>
    using bool_constant = integral_constant<bool, value>;

    using false_type = integral_constant<bool, false>;
    using true_type = integral_constant<bool, true>;

    template <typename ...>
    using void_t = void;

    template <typename T>
    struct remove_const
    {
        using type = T;
    };

    template <typename T>
    struct remove_const<const T>
    {
        using type = T;
    };

    template <typename T>
    using remove_const_t = typename remove_const<T>::type;

    template <typename T>
    struct remove_volatile
    {
        using type = T;
    };

    template <typename T>
    struct remove_volatile<volatile T>
    {
        using type = T;
    };

    template <typename T>
    using remove_volatile_t = typename remove_volatile<T>::type;

    template <typename T>
    using remove_cv_t = remove_volatile_t<remove_const_t<T>>;

    template <typename T>
    struct remove_cv
    {
        using type = remove_cv_t<T>;
    };

    template <typename T>
    using add_const_t = const T;

    template <class T>
    struct add_const
    {
        using type = add_const_t<T>;
    };

    template <typename T>
    using add_volatile_t = volatile T;

    template <class T>
    struct add_volatile
    {
        using type = add_volatile_t<T>;
    };

    template <typename T>
    using add_cv_t = const volatile T;

    template <typename T>
    struct add_cv
    {
        using type = add_cv_t<T>;
    };

    template <typename T>
    struct remove_reference
    {
        using type = T;
    };

    template <typename T>
    struct remove_reference<T &>
    {
        using type = T;
    };

    template <typename T>
    struct remove_reference<T &&>
    {
        using type = T;
    };

    template <typename T>
    using remove_reference_t = typename remove_reference<T>::type;

    template <typename T, typename U>
    struct is_same : false_type
    {
    };

    template <typename T>
    struct is_same<T, T> : true_type
    {
    };

    template <typename T, typename U>
    inline constexpr const bool is_same_v = is_same<T, U>::value;

    namespace details
    {
        template <typename T>
        struct is_void : false_type
        {
        };

        template <>
        struct is_void<void> : true_type
        {
        };
    }

    template <typename T>
    inline constexpr const bool is_void_v = details::is_void<remove_cv_t<T>>::value;

    template <typename T>
    struct is_void : bool_constant<is_void_v<T>>
    {
    };

    template <typename T>
    struct is_const : false_type
    {
    };

    template <typename T>
    struct is_const<const T> : true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_const_v = is_const<T>::value;

    template <typename T>
    struct is_lvalue_reference : std::false_type
    {
    };

    template <typename T>
    struct is_lvalue_reference<T &> : std::true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_lvalue_reference_v = is_lvalue_reference<T>::value;

    template <typename T>
    struct is_rvalue_reference : std::false_type
    {
    };

    template <typename T>
    struct is_rvalue_reference<T &&> : std::true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

    template <typename T>
    T &&declval() noexcept;

    namespace details
    {
        template <typename, typename T, typename ...Args>
        struct is_constructible : false_type
        {
        };

        template <typename T, typename ...Args>
        struct is_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...> : true_type
        {
        };

        template <typename, typename T, typename ...Args>
        struct is_nothrow_constructible : false_type
        {
        };

        template <typename T, typename ...Args>
        struct is_nothrow_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...>
            : bool_constant<noexcept(T(std::declval<Args>()...))>
        {
        };
    }

    template <typename T, typename ...Args>
    struct is_constructible : details::is_constructible<void, T, Args...>
    {
    };

    template <typename T, typename ...Args>
    inline constexpr const bool is_constructible_v = is_constructible<T, Args...>::value;

    template <typename T, typename ...Args>
    struct is_nothrow_constructible : details::is_nothrow_constructible<void, T, Args...>
    {
    };

    template <typename T, typename ...Args>
    inline constexpr const bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;

    template <typename T>
    struct is_move_constructible : is_constructible<T, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_move_constructible_v = is_constructible_v<T, T &&>;

    template <typename T>
    struct is_nothrow_move_constructible : is_nothrow_constructible<T, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_move_constructible_v = is_nothrow_constructible_v<T, T &&>;

    template <typename T>
    struct is_copy_constructible : is_constructible<T, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_copy_constructible_v = is_constructible_v<T, const T &>;

    template <typename T>
    struct is_nothrow_copy_constructible : is_nothrow_constructible<T, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_copy_constructible_v = is_nothrow_constructible_v<T, const T &>;
}

#endif /* !FOR_LIBCXX_TYPE_TRAITS */
