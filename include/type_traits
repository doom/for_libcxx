/*
** Created by doom on 09/10/18.
*/

#ifndef FOR_LIBCXX_TYPE_TRAITS
#define FOR_LIBCXX_TYPE_TRAITS

#include "cstddef"

namespace std
{
    namespace details
    {
        template <bool cond>
        struct conditional_t_impl
        {
            template <typename T, typename U>
            using func = T;
        };

        template <>
        struct conditional_t_impl<false>
        {
            template <typename T, typename U>
            using func = U;
        };
    }

    template <bool cond, typename T, typename U>
    using conditional_t = typename details::conditional_t_impl<cond>::template func<T, U>;

    template <bool cond, typename T, typename U>
    struct conditional
    {
        using type = conditional_t<cond, T, U>;
    };

    template <typename T, T v>
    struct integral_constant
    {
        using type = integral_constant<T, v>;

        using value_type = T;
        static constexpr const T value = v;

        constexpr operator value_type() const noexcept
        {
            return value;
        }

        constexpr value_type operator()() const noexcept
        {
            return value;
        }
    };

    template <bool value>
    using bool_constant = integral_constant<bool, value>;

    using false_type = integral_constant<bool, false>;
    using true_type = integral_constant<bool, true>;

    template <typename ...>
    using void_t = void;

    template <typename T>
    struct remove_const
    {
        using type = T;
    };

    template <typename T>
    struct remove_const<const T>
    {
        using type = T;
    };

    template <typename T>
    using remove_const_t = typename remove_const<T>::type;

    template <typename T>
    struct remove_volatile
    {
        using type = T;
    };

    template <typename T>
    struct remove_volatile<volatile T>
    {
        using type = T;
    };

    template <typename T>
    using remove_volatile_t = typename remove_volatile<T>::type;

    template <typename T>
    using remove_cv_t = remove_volatile_t<remove_const_t<T>>;

    template <typename T>
    struct remove_cv
    {
        using type = remove_cv_t<T>;
    };

    template <typename T>
    using add_const_t = const T;

    template <class T>
    struct add_const
    {
        using type = add_const_t<T>;
    };

    template <typename T>
    using add_volatile_t = volatile T;

    template <class T>
    struct add_volatile
    {
        using type = add_volatile_t<T>;
    };

    template <typename T>
    using add_cv_t = const volatile T;

    template <typename T>
    struct add_cv
    {
        using type = add_cv_t<T>;
    };

    template <typename T>
    struct remove_reference
    {
        using type = T;
    };

    template <typename T>
    struct remove_reference<T &>
    {
        using type = T;
    };

    template <typename T>
    struct remove_reference<T &&>
    {
        using type = T;
    };

    template <typename T>
    using remove_reference_t = typename remove_reference<T>::type;

    template <typename T, typename U>
    struct is_same : false_type
    {
    };

    template <typename T>
    struct is_same<T, T> : true_type
    {
    };

    template <typename T, typename U>
    inline constexpr const bool is_same_v = is_same<T, U>::value;

    namespace details
    {
        template <typename T>
        struct is_void : false_type
        {
        };

        template <>
        struct is_void<void> : true_type
        {
        };
    }

    template <typename T>
    inline constexpr const bool is_void_v = details::is_void<remove_cv_t<T>>::value;

    template <typename T>
    struct is_void : bool_constant<is_void_v<T>>
    {
    };

    template <typename T>
    struct is_const : false_type
    {
    };

    template <typename T>
    struct is_const<const T> : true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_const_v = is_const<T>::value;

    template <typename T>
    struct is_lvalue_reference : false_type
    {
    };

    template <typename T>
    struct is_lvalue_reference<T &> : true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_lvalue_reference_v = is_lvalue_reference<T>::value;

    template <typename T>
    struct is_rvalue_reference : false_type
    {
    };

    template <typename T>
    struct is_rvalue_reference<T &&> : true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

    template <typename T>
    inline constexpr const bool is_function_v = not is_const_v<add_const_t<T>>;

    template <typename T>
    struct is_function : bool_constant<is_function_v<T>>
    {
    };

    namespace details
    {
        template <typename T>
        struct is_pointer_impl : false_type
        {
        };

        template <typename T>
        struct is_pointer_impl<T *> : true_type
        {
        };
    }

    template <typename T>
    inline constexpr const bool is_pointer_v = details::is_pointer_impl<remove_cv_t<T>>::value;

    template <typename T>
    struct is_pointer : bool_constant<is_pointer_v<T>>
    {
    };

    template <typename T>
    struct is_array : false_type
    {
    };

    template <typename T>
    struct is_array<T[]> : true_type
    {
    };

    template <typename T, size_t N>
    struct is_array<T[N]> : true_type
    {
    };

    template <typename T>
    inline constexpr const bool is_array_v = is_array<T>::value;

    namespace details
    {
        template <typename T, bool is_function_type>
        struct add_pointer_impl
        {
            using type = remove_reference_t<T> *;
        };

        /** If T is a function but with qualifiers or through a reference */
        template <typename T>
        struct add_pointer_impl<T, true>
        {
            using type = T;
        };

        template <typename T, typename ...Args>
        struct add_pointer_impl<T(Args...), true>
        {
            using type = T (*)(Args...);
        };

        /** If T is a C variadic function */
        template <typename T, typename ...Args>
        struct add_pointer_impl<T(Args..., ...), true>
        {
            using type = T (*)(Args..., ...);
        };
    }

    template <typename T>
    struct add_pointer : details::add_pointer_impl<T, is_function_v<T>>
    {
    };

    template <typename T>
    using add_pointer_t = typename add_pointer<T>::type;

    template <typename T>
    struct remove_extent
    {
        using type = T;
    };

    template <typename T>
    struct remove_extent<T[]>
    {
        using type = T;
    };

    template <typename T, size_t N>
    struct remove_extent<T[N]>
    {
        using type = T;
    };

    template <typename T>
    using remove_extent_t = typename remove_extent<T>::type;

    template <typename T>
    struct decay
    {
    private:
        /** First, remove any reference */
        using Unrefed = remove_reference_t<T>;

    public:
        using type = conditional_t<is_array_v<Unrefed>,
            /** Arrays of T decay to pointers to T */
            remove_extent_t<Unrefed> *,
            conditional_t<is_function_v<Unrefed>,
                /** Function types decay to pointer to functions */
                add_pointer_t<Unrefed>,
                /** Other types lose their qualifiers */
                remove_cv_t<Unrefed>
            >
        >;
    };

    template <typename T>
    using decay_t = typename decay<T>::type;

    template <typename T>
    T &&declval() noexcept;

    namespace details
    {
        template <typename, typename T, typename ...Args>
        struct is_constructible : false_type
        {
        };

        template <typename T, typename ...Args>
        struct is_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...> : true_type
        {
        };

        template <typename, typename T, typename ...Args>
        struct is_nothrow_constructible : false_type
        {
        };

        template <typename T, typename ...Args>
        struct is_nothrow_constructible<void_t<decltype(T(std::declval<Args>()...))>, T, Args...>
            : bool_constant<noexcept(T(std::declval<Args>()...))>
        {
        };
    }

    template <typename T, typename ...Args>
    struct is_constructible : details::is_constructible<void, T, Args...>
    {
    };

    template <typename T, typename ...Args>
    inline constexpr const bool is_constructible_v = is_constructible<T, Args...>::value;

    template <typename T, typename... Args>
    struct is_trivially_constructible : bool_constant<is_constructible<T, Args...>::value
                                                      && __is_trivially_constructible(T, Args...)>
    {
    };

    template <typename T, typename ...Args>
    inline constexpr const bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;

    template <typename T, typename ...Args>
    struct is_nothrow_constructible : details::is_nothrow_constructible<void, T, Args...>
    {
    };

    template <typename T, typename ...Args>
    inline constexpr const bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;

    template <typename T>
    struct is_move_constructible : is_constructible<T, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_move_constructible_v = is_constructible_v<T, T &&>;

    template <typename T>
    struct is_trivially_move_constructible : is_trivially_constructible<T, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_trivially_move_constructible_v = is_trivially_constructible_v<T, T &&>;

    template <typename T>
    struct is_nothrow_move_constructible : is_nothrow_constructible<T, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_move_constructible_v = is_nothrow_constructible_v<T, T &&>;

    template <typename T>
    struct is_copy_constructible : is_constructible<T, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_copy_constructible_v = is_constructible_v<T, const T &>;

    template <typename T>
    struct is_trivially_copy_constructible : is_trivially_constructible<T, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_trivially_copy_constructible_v = is_trivially_constructible_v<T, const T &>;

    template <typename T>
    struct is_nothrow_copy_constructible : is_nothrow_constructible<T, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_copy_constructible_v = is_nothrow_constructible_v<T, const T &>;

    namespace details
    {
        template <typename, typename T, typename U>
        struct is_assignable : false_type
        {
        };

        template <typename T, typename U>
        struct is_assignable<void_t<decltype(std::declval<T>() = std::declval<U>())>, T, U> : true_type
        {
        };

        template <typename, typename T, typename U>
        struct is_nothrow_assignable : false_type
        {
        };

        template <typename T, typename U>
        struct is_nothrow_assignable<void_t<decltype(std::declval<T>() = std::declval<U>())>, T, U>
            : bool_constant<noexcept(std::declval<T &>() = std::declval<U>())>
        {
        };
    }

    template <typename T, typename U>
    struct is_assignable : details::is_assignable<void, T, U>
    {
    };

    template <typename T, typename U>
    inline constexpr const bool is_assignable_v = is_assignable<T, U>::value;

    template <typename T, typename U>
    struct is_trivially_assignable : bool_constant<is_assignable<T, U>::value
                                                   && __is_trivially_assignable(T, U)>
    {
    };

    template <typename T, typename U>
    inline constexpr const bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;

    template <typename T, typename U>
    struct is_nothrow_assignable : details::is_nothrow_assignable<void, T, U>
    {
    };

    template <typename T, typename U>
    inline constexpr const bool is_nothrow_assignable_v = is_nothrow_assignable<T, U>::value;

    template <typename T>
    struct is_move_assignable : is_assignable<T &, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_move_assignable_v = is_assignable_v<T &, T &&>;

    template <typename T>
    struct is_trivially_move_assignable : is_trivially_assignable<T &, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_trivially_move_assignable_v = is_trivially_assignable_v<T &, T &&>;

    template <typename T>
    struct is_nothrow_move_assignable : is_nothrow_assignable<T &, T &&>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_move_assignable_v = is_nothrow_assignable_v<T &, T &&>;

    template <typename T>
    struct is_copy_assignable : is_assignable<T &, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_copy_assignable_v = is_assignable_v<T &, const T &>;

    template <typename T>
    struct is_trivially_copy_assignable : is_trivially_assignable<T &, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_trivially_copy_assignable_v = is_trivially_assignable_v<T &, const T &>;

    template <typename T>
    struct is_nothrow_copy_assignable : is_nothrow_assignable<T &, const T &>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_copy_assignable_v = is_nothrow_assignable_v<T &, const T &>;

    namespace details
    {
        template <typename, typename T>
        struct is_destructible : false_type
        {
        };

        template <typename T>
        struct is_destructible<void_t<decltype(std::declval<T &>().~T())>, T> : true_type
        {
        };

        template <typename, typename T>
        struct is_nothrow_destructible : false_type
        {
        };

        template <typename T>
        struct is_nothrow_destructible<void_t<decltype(std::declval<T &>().~T())>, T>
            : bool_constant<noexcept(std::declval<T &>().~T())>
        {
        };
    }

    template <typename T>
    struct is_destructible : details::is_destructible<void, T>
    {
    };

    template <typename T>
    inline constexpr const bool is_destructible_v = is_destructible<T>::value;

    template <typename T>
    struct is_trivially_destructible : bool_constant<is_destructible<T>::value && __has_trivial_destructor(T)>
    {
    };

    template <typename T>
    inline constexpr const bool is_trivially_destructible_v = is_destructible_v<T> && __has_trivial_destructor(T);

    template <typename T>
    struct is_nothrow_destructible : details::is_nothrow_destructible<void, T>
    {
    };

    template <typename T>
    inline constexpr const bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;

    template <std::size_t Size, std::size_t Align>
    struct aligned_storage
    {
        struct type
        {
            alignas(Align) unsigned char data[Size];
        };
    };

    template <std::size_t Size, std::size_t Align>
    using aligned_storage_t = typename aligned_storage<Size, Align>::type;

    template <bool cond, typename T = void>
    struct enable_if
    {
    };

    template <typename T>
    struct enable_if<true, T>
    {
        using type = T;
    };

    template <bool cond, typename T = void>
    using enable_if_t = typename enable_if<cond, T>::type;
}

#endif /* !FOR_LIBCXX_TYPE_TRAITS */
