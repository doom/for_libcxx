/*
** Created by doom on 10/10/18.
*/

#ifndef FOR_LIBCXX_UTILITY
#define FOR_LIBCXX_UTILITY

#include <cstddef>
#include <type_traits>
#include <details/move_and_forward.hpp>

namespace std
{
    template <typename T>
    T &&declval() noexcept;

    struct in_place_t
    {
        explicit in_place_t() = default;
    };

    inline constexpr in_place_t in_place{};

    template <typename T, T ...Ints>
    class integer_sequence
    {
        static constexpr std::size_t size() noexcept
        {
            return sizeof...(Ints);
        }
    };

    template <std::size_t ...Ints>
    using index_sequence = std::integer_sequence<std::size_t, Ints...>;

    namespace details
    {
        template <typename Seq1, typename Seq2>
        struct concat_iseqs;

        template <std::size_t ...Seq1Values, std::size_t ...Seq2Values>
        struct concat_iseqs<std::index_sequence<Seq1Values...>, std::index_sequence<Seq2Values...>>
        {
            using type = std::index_sequence<Seq1Values..., (sizeof...(Seq1Values) + Seq2Values)...>;
        };

        template <std::size_t Max>
        struct make_iseq : concat_iseqs<
            typename make_iseq<Max / 2>::type,
            typename make_iseq<Max - (Max / 2)>::type
        >
        {
        };

        template <>
        struct make_iseq<1>
        {
            using type = std::index_sequence<0>;
        };

        template <typename FromT, typename ToT>
        struct iseq_cast;

        template <typename FromT, FromT ...Values, typename ToT>
        struct iseq_cast<std::integer_sequence<FromT, Values...>, ToT>
        {
            using type = std::integer_sequence<ToT, Values...>;
        };
    }

    template <typename T, T N>
    using make_integer_sequence = typename details::iseq_cast<typename details::make_iseq<N>::type, T>::type;

    template <std::size_t N>
    using make_index_sequence = typename details::make_iseq<N>::type;
}

#endif /* !FOR_LIBCXX_UTILITY */
